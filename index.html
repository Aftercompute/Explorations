<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>NEON DRIFT</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #000;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas { display: block; }
        #title-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            font-family: 'Courier New', monospace;
            color: #0ff;
            background: rgba(0,0,0,0.9);
            transition: opacity 0.8s;
        }
        #title-screen h1 {
            font-size: 28px;
            letter-spacing: 10px;
            font-weight: 300;
            margin-bottom: 8px;
            text-shadow: 0 0 20px #0ff;
        }
        #title-screen .sub {
            font-size: 10px;
            letter-spacing: 4px;
            opacity: 0.4;
            color: #fff;
            margin-bottom: 48px;
        }
        #title-screen .start {
            font-size: 13px;
            letter-spacing: 4px;
            opacity: 0.6;
            color: #fff;
            animation: pulse 2s ease-in-out infinite;
        }
        #title-screen .controls {
            position: absolute;
            bottom: 40px;
            font-size: 10px;
            letter-spacing: 1px;
            opacity: 0.3;
            color: #fff;
            text-align: center;
            line-height: 2;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>

<canvas id="c"></canvas>

<div id="title-screen">
    <h1>NEON DRIFT</h1>
    <div class="sub">FRAMTIDSSTADEN</div>
    <div class="start">TRYCK FÖR ATT FLYGA</div>
    <div class="controls">
        DRA FINGRET VARSOMHELST FÖR ATT STYRA
    </div>
</div>

<script>
// ── Canvas setup ──────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ── Game state ────────────────────────────────────────────────────
let state = 'title'; // title | playing
let shipX = 0;       // -1 to 1 (normalized screen position)
let shipY = 0.5;     // 0 to 1 (altitude - start high)
let targetX = 0;     // smoothed target for shipX
let targetY = 0.5;   // smoothed target for shipY
let speed = 0;
let distance = 0;
let camShake = 0;
let bankAngle = 0;   // visual banking of the plane
let pitchAngle = 0;  // visual pitch

// Flight altitude (world units) - the plane flies at this height
const FLIGHT_ALTITUDE = 14;
const ALTITUDE_RANGE = 10; // how much shipY affects altitude

// Touch
let touchId = null;
let touchStartX = 0;
let touchStartY = 0;
let touchShipStartX = 0;
let touchShipStartY = 0;

// Buildings - stored as world-space objects
const buildings = [];
const CITY_WIDTH = 60;    // how wide the city spreads
const VIEW_DEPTH = 140;
const BUILDING_SPAWN_INTERVAL = 5;
let nextBuildingZ = 15;

// Stars
const stars = [];
for (let i = 0; i < 120; i++) {
    stars.push({
        x: (Math.random() - 0.5) * 2,
        y: Math.random() * 0.6,
        z: Math.random() * VIEW_DEPTH,
        brightness: 0.2 + Math.random() * 0.6,
    });
}

// Horizon particles (flying particles for speed feel)
const particles = [];
for (let i = 0; i < 60; i++) {
    particles.push({
        x: (Math.random() - 0.5) * CITY_WIDTH,
        y: Math.random() * 30,
        z: Math.random() * VIEW_DEPTH,
    });
}

// ── Building generation ───────────────────────────────────────────
function generateBuilding(z) {
    // Organic placement: buildings scattered across the city, not just along a road
    // Use multiple placement strategies for variety
    const strategy = Math.random();
    let xPos;

    if (strategy < 0.3) {
        // Cluster near center (but leave a flight corridor)
        const side = Math.random() < 0.5 ? -1 : 1;
        xPos = side * (3 + Math.random() * 8);
    } else if (strategy < 0.7) {
        // Mid-range scattered
        xPos = (Math.random() - 0.5) * CITY_WIDTH * 0.6;
    } else {
        // Far out buildings (skyline)
        xPos = (Math.random() - 0.5) * CITY_WIDTH;
    }

    // Add organic jitter
    xPos += (Math.random() - 0.5) * 4;
    const zJitter = (Math.random() - 0.5) * 6;

    const w = 1.5 + Math.random() * 5;
    // Taller buildings in center, shorter at edges
    const distFromCenter = Math.abs(xPos);
    const heightBias = Math.max(0.3, 1 - distFromCenter / (CITY_WIDTH * 0.5));
    const h = 4 + Math.random() * 28 * heightBias;
    const d = 2 + Math.random() * 5;

    const b = {
        x: xPos,
        z: z + zJitter,
        w: w,
        h: h,
        d: d,
        color: randomCityColor(),
        windows: [],
        antenna: Math.random() < 0.3,
        antennaH: 1 + Math.random() * 3,
    };

    // Windows
    const cols = Math.max(1, Math.floor(w / 1.2));
    const rows = Math.max(1, Math.floor(h / 2));
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (Math.random() < 0.6) {
                b.windows.push({
                    u: (c + 0.5) / cols,
                    v: (r + 0.5) / rows,
                    lit: Math.random() < 0.4,
                });
            }
        }
    }

    return b;
}

function randomCityColor() {
    const colors = [
        '#0af', '#0ff', '#08f', '#f0a', '#a0f',
        '#0f8', '#fa0', '#08a', '#a08', '#0a8',
    ];
    return colors[Math.floor(Math.random() * colors.length)];
}

// Pre-generate initial buildings - scattered organically
for (let z = 15; z < VIEW_DEPTH; z += BUILDING_SPAWN_INTERVAL) {
    // 2-5 buildings per depth slice for a dense city feel
    const count = 2 + Math.floor(Math.random() * 4);
    for (let i = 0; i < count; i++) {
        buildings.push(generateBuilding(z));
    }
}
nextBuildingZ = VIEW_DEPTH;

// ── 3D projection ─────────────────────────────────────────────────
const FOV = 350;
const HORIZON_Y = 0.42; // normalized screen position of horizon

function project(wx, wy, wz) {
    // wz = distance ahead of camera (always positive for visible)
    if (wz <= 0.5) return null;
    const scale = FOV / wz;
    // Camera position based on ship controls
    const camX = shipX * CITY_WIDTH * 0.15;
    const camY = FLIGHT_ALTITUDE + shipY * ALTITUDE_RANGE;
    const sx = canvas.width / 2 + (wx - camX) * scale;
    const sy = canvas.height * HORIZON_Y - (wy - camY) * scale;
    return { x: sx, y: sy, scale: scale };
}

// ── Draw helpers ──────────────────────────────────────────────────
function drawLine(x1, y1, x2, y2, color, alpha, width) {
    ctx.strokeStyle = color;
    ctx.globalAlpha = alpha;
    ctx.lineWidth = width || 1;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}

function drawBuilding(b, camZ) {
    const relZ = b.z - camZ;
    if (relZ < 1 || relZ > VIEW_DEPTH) return;

    const frontZ = relZ;
    const backZ = relZ + b.d;
    const fade = 1 - Math.max(0, Math.min(1, (relZ - VIEW_DEPTH * 0.5) / (VIEW_DEPTH * 0.5)));

    // 4 bottom corners, 4 top corners
    const x1 = b.x - b.w / 2;
    const x2 = b.x + b.w / 2;
    const y0 = 0;
    const y1 = b.h;

    const fl = project(x1, y0, frontZ);
    const fr = project(x2, y0, frontZ);
    const ftl = project(x1, y1, frontZ);
    const ftr = project(x2, y1, frontZ);
    const bl = project(x1, y0, backZ);
    const br = project(x2, y0, backZ);
    const btl = project(x1, y1, backZ);
    const btr = project(x2, y1, backZ);

    if (!fl || !fr || !ftl || !ftr) return;

    const alpha = fade * 0.7;
    const col = b.color;

    // Front face
    drawLine(fl.x, fl.y, fr.x, fr.y, col, alpha, 1);
    drawLine(fr.x, fr.y, ftr.x, ftr.y, col, alpha, 1);
    drawLine(ftr.x, ftr.y, ftl.x, ftl.y, col, alpha, 1);
    drawLine(ftl.x, ftl.y, fl.x, fl.y, col, alpha, 1);

    // Back face (if visible)
    if (bl && br && btl && btr) {
        drawLine(bl.x, bl.y, br.x, br.y, col, alpha * 0.4, 1);
        drawLine(br.x, br.y, btr.x, btr.y, col, alpha * 0.4, 1);
        drawLine(btr.x, btr.y, btl.x, btl.y, col, alpha * 0.4, 1);
        drawLine(btl.x, btl.y, bl.x, bl.y, col, alpha * 0.4, 1);

        // Connecting edges
        drawLine(fl.x, fl.y, bl.x, bl.y, col, alpha * 0.3, 1);
        drawLine(fr.x, fr.y, br.x, br.y, col, alpha * 0.3, 1);
        drawLine(ftl.x, ftl.y, btl.x, btl.y, col, alpha * 0.3, 1);
        drawLine(ftr.x, ftr.y, btr.x, btr.y, col, alpha * 0.3, 1);
    }

    // Windows on front face
    for (const win of b.windows) {
        const wx = x1 + win.u * b.w;
        const wy = win.v * b.h;
        const wp = project(wx, wy, frontZ);
        if (wp) {
            const ws = Math.max(1, 2 * wp.scale / FOV);
            ctx.globalAlpha = fade * (win.lit ? 0.8 : 0.15);
            ctx.fillStyle = win.lit ? '#ff8' : '#445';
            ctx.fillRect(wp.x - ws, wp.y - ws, ws * 2, ws * 1.5);
        }
    }

    // Antenna
    if (b.antenna && ftl && ftr) {
        const ax = b.x;
        const atop = project(ax, y1 + b.antennaH, frontZ);
        const abase = project(ax, y1, frontZ);
        if (atop && abase) {
            drawLine(abase.x, abase.y, atop.x, atop.y, '#f44', alpha * 0.8, 1);
            // Blinking light
            if (Math.sin(Date.now() * 0.005 + b.x) > 0.3) {
                ctx.globalAlpha = alpha * 0.9;
                ctx.fillStyle = '#f44';
                ctx.beginPath();
                ctx.arc(atop.x, atop.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
}

function drawShip() {
    const cx = canvas.width / 2;
    const cy = canvas.height * 0.58;

    // Smooth banking animation
    const targetBank = -shipX * 30;
    bankAngle += (targetBank - bankAngle) * 0.08;
    // Gentle pitch based on vertical movement
    const targetPitch = (targetY - shipY) * 10;
    pitchAngle += (targetPitch - pitchAngle) * 0.05;

    ctx.save();
    ctx.translate(cx, cy + pitchAngle * 0.5);
    ctx.rotate(bankAngle * Math.PI / 180);

    const s = Math.min(canvas.width, canvas.height) * 0.035;

    // Paper airplane shadow/glow
    ctx.shadowColor = '#0ff';
    ctx.shadowBlur = 15;

    // === Folded paper airplane ===
    // Left wing (main fold)
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = '#0bf';
    ctx.beginPath();
    ctx.moveTo(0, -s * 2.0);           // nose tip
    ctx.lineTo(-s * 1.8, s * 0.6);     // left wing tip
    ctx.lineTo(-s * 0.15, s * 0.3);    // left inner fold
    ctx.lineTo(0, s * 1.0);            // tail
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Right wing (main fold)
    ctx.globalAlpha = 0.65;
    ctx.fillStyle = '#089';
    ctx.beginPath();
    ctx.moveTo(0, -s * 2.0);           // nose tip
    ctx.lineTo(s * 1.8, s * 0.6);      // right wing tip
    ctx.lineTo(s * 0.15, s * 0.3);     // right inner fold
    ctx.lineTo(0, s * 1.0);            // tail
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Center fold line (the crease of the paper)
    ctx.beginPath();
    ctx.moveTo(0, -s * 2.0);
    ctx.lineTo(0, s * 1.0);
    ctx.strokeStyle = '#fff';
    ctx.globalAlpha = 0.5;
    ctx.lineWidth = 1;
    ctx.stroke();

    // Small fold detail on wings
    ctx.beginPath();
    ctx.moveTo(0, -s * 1.2);
    ctx.lineTo(-s * 0.8, s * 0.4);
    ctx.strokeStyle = '#0af';
    ctx.globalAlpha = 0.3;
    ctx.lineWidth = 0.5;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0, -s * 1.2);
    ctx.lineTo(s * 0.8, s * 0.4);
    ctx.stroke();

    ctx.shadowBlur = 0;
    ctx.restore();
}

function drawCityGround(camZ) {
    // City block grid on the ground - seen from above while flying
    const gridSpacing = 8;
    const numLines = 25;
    const citySpread = CITY_WIDTH * 0.8;

    // Horizontal ground lines (streets running left-right)
    for (let i = 1; i <= numLines; i++) {
        const z = (i * gridSpacing) - (camZ % gridSpacing);
        if (z < 1) continue;
        const left = project(-citySpread, 0, z);
        const right = project(citySpread, 0, z);
        if (left && right) {
            const fade = 1 - i / numLines;
            drawLine(left.x, left.y, right.x, right.y, '#182038', fade * 0.4, 1);
        }
    }

    // Vertical ground lines (streets running into distance)
    const streetPositions = [];
    for (let x = -citySpread; x <= citySpread; x += 10) {
        streetPositions.push(x + (Math.sin(x * 0.3) * 2)); // slight organic offset
    }

    const steps = 30;
    for (const streetX of streetPositions) {
        ctx.strokeStyle = '#182038';
        ctx.lineWidth = 1;
        ctx.beginPath();
        let started = false;

        for (let i = 0; i <= steps; i++) {
            const z = 3 + (i / steps) * VIEW_DEPTH;
            const p = project(streetX, 0, z);
            if (p) {
                const fade = 1 - i / steps;
                ctx.globalAlpha = fade * 0.3;
                if (!started) {
                    ctx.moveTo(p.x, p.y);
                    started = true;
                } else {
                    ctx.lineTo(p.x, p.y);
                }
            }
        }
        ctx.stroke();
    }
}

function drawStars(camZ) {
    for (const star of stars) {
        const sx = canvas.width / 2 + star.x * canvas.width * 0.8;
        const sy = star.y * canvas.height * HORIZON_Y * 2;
        ctx.globalAlpha = star.brightness * 0.6;
        ctx.fillStyle = '#fff';
        ctx.fillRect(sx, sy, 1, 1);
    }
}

function drawParticles(camZ) {
    for (const p of particles) {
        const relZ = ((p.z - camZ) % VIEW_DEPTH + VIEW_DEPTH) % VIEW_DEPTH;
        const proj = project(p.x, p.y, relZ);
        if (proj && relZ > 2) {
            const fade = 1 - relZ / VIEW_DEPTH;
            ctx.globalAlpha = fade * 0.3;
            ctx.fillStyle = '#0ff';
            const sz = Math.max(0.5, 1.5 * proj.scale / FOV);
            ctx.fillRect(proj.x, proj.y, sz, sz);
        }
    }
}

function drawHUD() {
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = '#0ff';
    ctx.font = '11px Courier New';
    ctx.textAlign = 'left';
    ctx.fillText('DIST ' + Math.floor(distance), 16, 24);

    ctx.textAlign = 'right';
    const spd = Math.floor(speed * 800);
    ctx.fillText('SPD ' + spd, canvas.width - 16, 24);

    // Altitude indicator
    ctx.textAlign = 'center';
    const alt = Math.floor(FLIGHT_ALTITUDE + shipY * ALTITUDE_RANGE);
    ctx.fillText('ALT ' + alt, canvas.width / 2, 24);
}

function drawScanlines() {
    ctx.globalAlpha = 0.03;
    ctx.fillStyle = '#000';
    for (let y = 0; y < canvas.height; y += 3) {
        ctx.fillRect(0, y, canvas.width, 1);
    }
}

// ── Main render ───────────────────────────────────────────────────
function render() {
    // Clear
    ctx.globalAlpha = 1;

    // Gradient sky
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height * HORIZON_Y);
    grad.addColorStop(0, '#020210');
    grad.addColorStop(0.7, '#050520');
    grad.addColorStop(1, '#0a0a30');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height * HORIZON_Y + 20);

    // Ground
    const gGrad = ctx.createLinearGradient(0, canvas.height * HORIZON_Y, 0, canvas.height);
    gGrad.addColorStop(0, '#0a0a20');
    gGrad.addColorStop(1, '#000008');
    ctx.fillStyle = gGrad;
    ctx.fillRect(0, canvas.height * HORIZON_Y - 1, canvas.width, canvas.height);

    // Horizon glow
    ctx.globalAlpha = 0.15;
    const hGrad = ctx.createRadialGradient(
        canvas.width / 2, canvas.height * HORIZON_Y, 0,
        canvas.width / 2, canvas.height * HORIZON_Y, canvas.width * 0.5
    );
    hGrad.addColorStop(0, '#08f');
    hGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = hGrad;
    ctx.fillRect(0, canvas.height * HORIZON_Y - 100, canvas.width, 200);

    ctx.globalAlpha = 1;

    drawStars(distance);
    drawCityGround(distance);
    drawParticles(distance);

    // Sort buildings by distance (far first)
    const sortedBuildings = buildings
        .map(b => ({ b, relZ: b.z - distance }))
        .filter(o => o.relZ > 0 && o.relZ < VIEW_DEPTH)
        .sort((a, b) => b.relZ - a.relZ);

    for (const { b } of sortedBuildings) {
        drawBuilding(b, distance);
    }

    drawShip();
    drawHUD();
    drawScanlines();
}

// ── Game update ───────────────────────────────────────────────────
function update() {
    if (state !== 'playing') return;

    // Accelerate gradually
    speed += 0.00003;
    speed = Math.min(speed, 0.5);

    distance += speed;

    // Smooth steering - lerp ship position towards target
    const lerpSpeed = 0.06;
    shipX += (targetX - shipX) * lerpSpeed;
    shipY += (targetY - shipY) * lerpSpeed;

    // Spawn new buildings as we move forward
    while (nextBuildingZ < distance + VIEW_DEPTH) {
        // Dense city: 3-6 buildings per depth slice
        const count = 3 + Math.floor(Math.random() * 4);
        for (let i = 0; i < count; i++) {
            buildings.push(generateBuilding(nextBuildingZ));
        }
        nextBuildingZ += BUILDING_SPAWN_INTERVAL * (0.5 + Math.random() * 0.8);
    }

    // Remove old buildings far behind
    for (let i = buildings.length - 1; i >= 0; i--) {
        if (buildings[i].z < distance - 10) {
            buildings.splice(i, 1);
        }
    }

    // Flicker random windows occasionally
    if (Math.random() < 0.03) {
        const b = buildings[Math.floor(Math.random() * buildings.length)];
        if (b && b.windows.length > 0) {
            const w = b.windows[Math.floor(Math.random() * b.windows.length)];
            w.lit = !w.lit;
        }
    }
}

// ── Touch / Mouse controls ────────────────────────────────────────
function startGame() {
    if (state === 'title') {
        state = 'playing';
        speed = 0.04;
        const titleScreen = document.getElementById('title-screen');
        titleScreen.style.opacity = '0';
        setTimeout(() => { titleScreen.style.display = 'none'; }, 800);
    }
}

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (state === 'title') { startGame(); return; }

    const t = e.changedTouches[0];
    if (touchId === null) {
        touchId = t.identifier;
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touchShipStartX = targetX;
        touchShipStartY = targetY;
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const t of e.changedTouches) {
        if (t.identifier === touchId) {
            const dx = (t.clientX - touchStartX) / (canvas.width * 0.25);
            const dy = (t.clientY - touchStartY) / (canvas.height * 0.25);
            targetX = Math.max(-1, Math.min(1, touchShipStartX + dx));
            targetY = Math.max(-0.5, Math.min(1, touchShipStartY - dy));
        }
    }
}, { passive: false });

canvas.addEventListener('touchend', e => {
    for (const t of e.changedTouches) {
        if (t.identifier === touchId) {
            touchId = null;
        }
    }
});

canvas.addEventListener('touchcancel', () => {
    touchId = null;
});

// Mouse fallback for desktop
let mouseDown = false;
let mouseStartX = 0, mouseStartY = 0;
let mouseShipStartX = 0, mouseShipStartY = 0;

canvas.addEventListener('mousedown', e => {
    if (state === 'title') { startGame(); return; }
    mouseDown = true;
    mouseStartX = e.clientX;
    mouseStartY = e.clientY;
    mouseShipStartX = targetX;
    mouseShipStartY = targetY;
});

canvas.addEventListener('mousemove', e => {
    if (!mouseDown) return;
    const dx = (e.clientX - mouseStartX) / (canvas.width * 0.25);
    const dy = (e.clientY - mouseStartY) / (canvas.height * 0.25);
    targetX = Math.max(-1, Math.min(1, mouseShipStartX + dx));
    targetY = Math.max(-0.5, Math.min(1, mouseShipStartY - dy));
});

canvas.addEventListener('mouseup', () => { mouseDown = false; });
canvas.addEventListener('mouseleave', () => { mouseDown = false; });

// Title screen touch/click
document.getElementById('title-screen').addEventListener('click', startGame);
document.getElementById('title-screen').addEventListener('touchstart', e => {
    e.preventDefault();
    startGame();
}, { passive: false });

// ── Game loop ─────────────────────────────────────────────────────
function loop() {
    requestAnimationFrame(loop);
    update();
    render();
}
loop();
</script>
</body>
</html>
