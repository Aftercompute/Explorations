<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>NEON DRIFT</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #000;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas { display: block; }
        #title-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            font-family: 'Courier New', monospace;
            color: #0ff;
            background: rgba(0,0,0,0.9);
            transition: opacity 0.8s;
        }
        #title-screen h1 {
            font-size: 28px;
            letter-spacing: 10px;
            font-weight: 300;
            margin-bottom: 8px;
            text-shadow: 0 0 20px #0ff;
        }
        #title-screen .sub {
            font-size: 10px;
            letter-spacing: 4px;
            opacity: 0.4;
            color: #fff;
            margin-bottom: 48px;
        }
        #title-screen .start {
            font-size: 13px;
            letter-spacing: 4px;
            opacity: 0.6;
            color: #fff;
            animation: pulse 2s ease-in-out infinite;
        }
        #title-screen .controls {
            position: absolute;
            bottom: 40px;
            font-size: 10px;
            letter-spacing: 1px;
            opacity: 0.3;
            color: #fff;
            text-align: center;
            line-height: 2;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>

<canvas id="c"></canvas>

<div id="title-screen">
    <h1>NEON DRIFT</h1>
    <div class="sub">FRAMTIDSSTADEN</div>
    <div class="start">TRYCK FÖR ATT FLYGA</div>
    <div class="controls">
        DRA FINGRET VARSOMHELST FÖR ATT STYRA
    </div>
</div>

<script>
// ── Canvas setup ──────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ── Game state ────────────────────────────────────────────────────
let state = 'title'; // title | playing
let shipX = 0;       // -1 to 1 (normalized screen position)
let shipY = 0.2;     // -1 to 1
let speed = 0;
let distance = 0;
let camShake = 0;

// Touch
let touchId = null;
let touchStartX = 0;
let touchStartY = 0;
let touchShipStartX = 0;
let touchShipStartY = 0;

// Buildings - stored as world-space objects
const buildings = [];
const ROAD_WIDTH = 12;
const VIEW_DEPTH = 120;
const BUILDING_SPAWN_INTERVAL = 8;
let nextBuildingZ = 20;

// Stars
const stars = [];
for (let i = 0; i < 120; i++) {
    stars.push({
        x: (Math.random() - 0.5) * 2,
        y: Math.random() * 0.6,
        z: Math.random() * VIEW_DEPTH,
        brightness: 0.2 + Math.random() * 0.6,
    });
}

// Horizon particles (flying particles for speed feel)
const particles = [];
for (let i = 0; i < 40; i++) {
    particles.push({
        x: (Math.random() - 0.5) * ROAD_WIDTH * 3,
        y: Math.random() * 15,
        z: Math.random() * VIEW_DEPTH,
    });
}

// ── Building generation ───────────────────────────────────────────
function generateBuilding(z) {
    const side = Math.random() < 0.5 ? -1 : 1;
    const laneOffset = ROAD_WIDTH / 2 + 1 + Math.random() * 8;
    const w = 1.5 + Math.random() * 4;
    const h = 4 + Math.random() * 20;
    const d = 2 + Math.random() * 5;

    const b = {
        x: side * laneOffset + (Math.random() - 0.5) * 2,
        z: z,
        w: w,
        h: h,
        d: d,
        color: randomCityColor(),
        windows: [],
        antenna: Math.random() < 0.3,
        antennaH: 1 + Math.random() * 3,
    };

    // Windows
    const cols = Math.max(1, Math.floor(w / 1.2));
    const rows = Math.max(1, Math.floor(h / 2));
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (Math.random() < 0.6) {
                b.windows.push({
                    u: (c + 0.5) / cols,
                    v: (r + 0.5) / rows,
                    lit: Math.random() < 0.4,
                });
            }
        }
    }

    return b;
}

function randomCityColor() {
    const colors = [
        '#0af', '#0ff', '#08f', '#f0a', '#a0f',
        '#0f8', '#fa0', '#08a', '#a08', '#0a8',
    ];
    return colors[Math.floor(Math.random() * colors.length)];
}

// Pre-generate initial buildings
for (let z = 20; z < VIEW_DEPTH; z += BUILDING_SPAWN_INTERVAL) {
    // Multiple buildings per row
    const count = 1 + Math.floor(Math.random() * 3);
    for (let i = 0; i < count; i++) {
        buildings.push(generateBuilding(z));
    }
    // Sometimes add buildings on both sides
    if (Math.random() < 0.5) {
        const b = generateBuilding(z);
        b.x = -b.x; // flip side
        buildings.push(b);
    }
}
nextBuildingZ = VIEW_DEPTH;

// ── 3D projection ─────────────────────────────────────────────────
const FOV = 300;
const HORIZON_Y = 0.38; // normalized screen position of horizon

function project(wx, wy, wz) {
    // wz = distance ahead of camera (always positive for visible)
    if (wz <= 0.5) return null;
    const scale = FOV / wz;
    const sx = canvas.width / 2 + (wx - shipX * ROAD_WIDTH * 0.4) * scale;
    const sy = canvas.height * HORIZON_Y - (wy - shipY * 2) * scale;
    return { x: sx, y: sy, scale: scale };
}

// ── Draw helpers ──────────────────────────────────────────────────
function drawLine(x1, y1, x2, y2, color, alpha, width) {
    ctx.strokeStyle = color;
    ctx.globalAlpha = alpha;
    ctx.lineWidth = width || 1;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}

function drawBuilding(b, camZ) {
    const relZ = b.z - camZ;
    if (relZ < 1 || relZ > VIEW_DEPTH) return;

    const frontZ = relZ;
    const backZ = relZ + b.d;
    const fade = 1 - Math.max(0, Math.min(1, (relZ - VIEW_DEPTH * 0.5) / (VIEW_DEPTH * 0.5)));

    // 4 bottom corners, 4 top corners
    const x1 = b.x - b.w / 2;
    const x2 = b.x + b.w / 2;
    const y0 = 0;
    const y1 = b.h;

    const fl = project(x1, y0, frontZ);
    const fr = project(x2, y0, frontZ);
    const ftl = project(x1, y1, frontZ);
    const ftr = project(x2, y1, frontZ);
    const bl = project(x1, y0, backZ);
    const br = project(x2, y0, backZ);
    const btl = project(x1, y1, backZ);
    const btr = project(x2, y1, backZ);

    if (!fl || !fr || !ftl || !ftr) return;

    const alpha = fade * 0.7;
    const col = b.color;

    // Front face
    drawLine(fl.x, fl.y, fr.x, fr.y, col, alpha, 1);
    drawLine(fr.x, fr.y, ftr.x, ftr.y, col, alpha, 1);
    drawLine(ftr.x, ftr.y, ftl.x, ftl.y, col, alpha, 1);
    drawLine(ftl.x, ftl.y, fl.x, fl.y, col, alpha, 1);

    // Back face (if visible)
    if (bl && br && btl && btr) {
        drawLine(bl.x, bl.y, br.x, br.y, col, alpha * 0.4, 1);
        drawLine(br.x, br.y, btr.x, btr.y, col, alpha * 0.4, 1);
        drawLine(btr.x, btr.y, btl.x, btl.y, col, alpha * 0.4, 1);
        drawLine(btl.x, btl.y, bl.x, bl.y, col, alpha * 0.4, 1);

        // Connecting edges
        drawLine(fl.x, fl.y, bl.x, bl.y, col, alpha * 0.3, 1);
        drawLine(fr.x, fr.y, br.x, br.y, col, alpha * 0.3, 1);
        drawLine(ftl.x, ftl.y, btl.x, btl.y, col, alpha * 0.3, 1);
        drawLine(ftr.x, ftr.y, btr.x, btr.y, col, alpha * 0.3, 1);
    }

    // Windows on front face
    for (const win of b.windows) {
        const wx = x1 + win.u * b.w;
        const wy = win.v * b.h;
        const wp = project(wx, wy, frontZ);
        if (wp) {
            const ws = Math.max(1, 2 * wp.scale / FOV);
            ctx.globalAlpha = fade * (win.lit ? 0.8 : 0.15);
            ctx.fillStyle = win.lit ? '#ff8' : '#445';
            ctx.fillRect(wp.x - ws, wp.y - ws, ws * 2, ws * 1.5);
        }
    }

    // Antenna
    if (b.antenna && ftl && ftr) {
        const ax = b.x;
        const atop = project(ax, y1 + b.antennaH, frontZ);
        const abase = project(ax, y1, frontZ);
        if (atop && abase) {
            drawLine(abase.x, abase.y, atop.x, atop.y, '#f44', alpha * 0.8, 1);
            // Blinking light
            if (Math.sin(Date.now() * 0.005 + b.x) > 0.3) {
                ctx.globalAlpha = alpha * 0.9;
                ctx.fillStyle = '#f44';
                ctx.beginPath();
                ctx.arc(atop.x, atop.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
}

function drawShip() {
    const cx = canvas.width / 2;
    const cy = canvas.height * 0.62;
    const tilt = -shipX * 15; // visual tilt based on horizontal position

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(tilt * Math.PI / 180);

    const s = Math.min(canvas.width, canvas.height) * 0.04;

    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 1.5;
    ctx.shadowColor = '#0ff';
    ctx.shadowBlur = 10;

    // Main body - triangle
    ctx.beginPath();
    ctx.moveTo(0, -s * 1.8);
    ctx.lineTo(-s * 1.2, s * 1.0);
    ctx.lineTo(-s * 0.3, s * 0.6);
    ctx.lineTo(0, s * 1.2);
    ctx.lineTo(s * 0.3, s * 0.6);
    ctx.lineTo(s * 1.2, s * 1.0);
    ctx.closePath();
    ctx.stroke();

    // Cockpit line
    ctx.beginPath();
    ctx.moveTo(0, -s * 1.0);
    ctx.lineTo(-s * 0.25, s * 0.1);
    ctx.lineTo(s * 0.25, s * 0.1);
    ctx.closePath();
    ctx.strokeStyle = '#08f';
    ctx.globalAlpha = 0.6;
    ctx.stroke();

    // Engine glow
    const flicker = 0.7 + Math.sin(Date.now() * 0.02) * 0.3;
    ctx.globalAlpha = flicker * 0.5;
    ctx.strokeStyle = '#48f';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-s * 0.3, s * 0.8);
    ctx.lineTo(0, s * 1.6 + Math.random() * s * 0.3);
    ctx.lineTo(s * 0.3, s * 0.8);
    ctx.stroke();

    ctx.shadowBlur = 0;
    ctx.restore();
}

function drawRoad(camZ) {
    // Ground grid lines going into the distance
    const gridSpacing = 6;
    const numLines = 20;

    // Horizontal ground lines
    for (let i = 1; i <= numLines; i++) {
        const z = (i * gridSpacing) - (camZ % gridSpacing);
        const left = project(-ROAD_WIDTH * 2, 0, z);
        const right = project(ROAD_WIDTH * 2, 0, z);
        if (left && right) {
            const fade = 1 - i / numLines;
            drawLine(left.x, left.y, right.x, right.y, '#224', fade * 0.3, 1);
        }
    }

    // Road edge lines (two parallel lines going into distance)
    const steps = 40;
    for (let side = -1; side <= 1; side += 2) {
        ctx.strokeStyle = '#0af';
        ctx.lineWidth = 1;
        ctx.beginPath();
        let started = false;

        for (let i = 0; i <= steps; i++) {
            const z = 2 + (i / steps) * VIEW_DEPTH;
            const p = project(side * ROAD_WIDTH / 2, 0, z);
            if (p) {
                const fade = 1 - i / steps;
                if (!started) {
                    ctx.moveTo(p.x, p.y);
                    started = true;
                } else {
                    ctx.globalAlpha = fade * 0.5;
                    ctx.lineTo(p.x, p.y);
                }
            }
        }
        ctx.stroke();
    }

    // Center dashed line
    for (let i = 0; i < 20; i++) {
        const z1 = (i * 6 + 2) - (camZ % 6);
        const z2 = z1 + 3;
        if (z1 < 1) continue;
        const p1 = project(0, 0, z1);
        const p2 = project(0, 0, z2);
        if (p1 && p2) {
            const fade = 1 - z1 / VIEW_DEPTH;
            drawLine(p1.x, p1.y, p2.x, p2.y, '#046', fade * 0.4, 1);
        }
    }
}

function drawStars(camZ) {
    for (const star of stars) {
        const sx = canvas.width / 2 + star.x * canvas.width * 0.8;
        const sy = star.y * canvas.height * HORIZON_Y * 2;
        ctx.globalAlpha = star.brightness * 0.6;
        ctx.fillStyle = '#fff';
        ctx.fillRect(sx, sy, 1, 1);
    }
}

function drawParticles(camZ) {
    for (const p of particles) {
        const relZ = ((p.z - camZ) % VIEW_DEPTH + VIEW_DEPTH) % VIEW_DEPTH;
        const proj = project(p.x, p.y, relZ);
        if (proj && relZ > 2) {
            const fade = 1 - relZ / VIEW_DEPTH;
            ctx.globalAlpha = fade * 0.3;
            ctx.fillStyle = '#0ff';
            const sz = Math.max(0.5, 1.5 * proj.scale / FOV);
            ctx.fillRect(proj.x, proj.y, sz, sz);
        }
    }
}

function drawHUD() {
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = '#0ff';
    ctx.font = '11px Courier New';
    ctx.textAlign = 'left';
    ctx.fillText('DIST ' + Math.floor(distance), 16, 24);

    ctx.textAlign = 'right';
    const spd = Math.floor(speed * 800);
    ctx.fillText('SPD ' + spd, canvas.width - 16, 24);

    // Altitude indicator
    ctx.textAlign = 'center';
    ctx.fillText('ALT ' + Math.floor((1 - shipY) * 100), canvas.width / 2, 24);
}

function drawScanlines() {
    ctx.globalAlpha = 0.03;
    ctx.fillStyle = '#000';
    for (let y = 0; y < canvas.height; y += 3) {
        ctx.fillRect(0, y, canvas.width, 1);
    }
}

// ── Main render ───────────────────────────────────────────────────
function render() {
    // Clear
    ctx.globalAlpha = 1;

    // Gradient sky
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height * HORIZON_Y);
    grad.addColorStop(0, '#020210');
    grad.addColorStop(0.7, '#050520');
    grad.addColorStop(1, '#0a0a30');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height * HORIZON_Y + 20);

    // Ground
    const gGrad = ctx.createLinearGradient(0, canvas.height * HORIZON_Y, 0, canvas.height);
    gGrad.addColorStop(0, '#0a0a20');
    gGrad.addColorStop(1, '#000008');
    ctx.fillStyle = gGrad;
    ctx.fillRect(0, canvas.height * HORIZON_Y - 1, canvas.width, canvas.height);

    // Horizon glow
    ctx.globalAlpha = 0.15;
    const hGrad = ctx.createRadialGradient(
        canvas.width / 2, canvas.height * HORIZON_Y, 0,
        canvas.width / 2, canvas.height * HORIZON_Y, canvas.width * 0.5
    );
    hGrad.addColorStop(0, '#08f');
    hGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = hGrad;
    ctx.fillRect(0, canvas.height * HORIZON_Y - 100, canvas.width, 200);

    ctx.globalAlpha = 1;

    drawStars(distance);
    drawRoad(distance);
    drawParticles(distance);

    // Sort buildings by distance (far first)
    const sortedBuildings = buildings
        .map(b => ({ b, relZ: b.z - distance }))
        .filter(o => o.relZ > 0 && o.relZ < VIEW_DEPTH)
        .sort((a, b) => b.relZ - a.relZ);

    for (const { b } of sortedBuildings) {
        drawBuilding(b, distance);
    }

    drawShip();
    drawHUD();
    drawScanlines();
}

// ── Game update ───────────────────────────────────────────────────
function update() {
    if (state !== 'playing') return;

    // Accelerate gradually
    speed += 0.00003;
    speed = Math.min(speed, 0.5);

    distance += speed;

    // Spawn new buildings as we move forward
    while (nextBuildingZ < distance + VIEW_DEPTH) {
        const count = 1 + Math.floor(Math.random() * 3);
        for (let i = 0; i < count; i++) {
            buildings.push(generateBuilding(nextBuildingZ));
        }
        if (Math.random() < 0.6) {
            const b = generateBuilding(nextBuildingZ);
            b.x = -b.x;
            buildings.push(b);
        }
        nextBuildingZ += BUILDING_SPAWN_INTERVAL * (0.6 + Math.random() * 0.8);
    }

    // Remove old buildings far behind
    for (let i = buildings.length - 1; i >= 0; i--) {
        if (buildings[i].z < distance - 10) {
            buildings.splice(i, 1);
        }
    }

    // Flicker random windows occasionally
    if (Math.random() < 0.02) {
        const b = buildings[Math.floor(Math.random() * buildings.length)];
        if (b && b.windows.length > 0) {
            const w = b.windows[Math.floor(Math.random() * b.windows.length)];
            w.lit = !w.lit;
        }
    }
}

// ── Touch / Mouse controls ────────────────────────────────────────
function startGame() {
    if (state === 'title') {
        state = 'playing';
        speed = 0.04;
        const titleScreen = document.getElementById('title-screen');
        titleScreen.style.opacity = '0';
        setTimeout(() => { titleScreen.style.display = 'none'; }, 800);
    }
}

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (state === 'title') { startGame(); return; }

    const t = e.changedTouches[0];
    if (touchId === null) {
        touchId = t.identifier;
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touchShipStartX = shipX;
        touchShipStartY = shipY;
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const t of e.changedTouches) {
        if (t.identifier === touchId) {
            const dx = (t.clientX - touchStartX) / (canvas.width * 0.3);
            const dy = (t.clientY - touchStartY) / (canvas.height * 0.3);
            shipX = Math.max(-1, Math.min(1, touchShipStartX + dx));
            shipY = Math.max(-0.5, Math.min(1, touchShipStartY + dy));
        }
    }
}, { passive: false });

canvas.addEventListener('touchend', e => {
    for (const t of e.changedTouches) {
        if (t.identifier === touchId) {
            touchId = null;
        }
    }
});

canvas.addEventListener('touchcancel', () => {
    touchId = null;
});

// Mouse fallback for desktop
let mouseDown = false;
let mouseStartX = 0, mouseStartY = 0;
let mouseShipStartX = 0, mouseShipStartY = 0;

canvas.addEventListener('mousedown', e => {
    if (state === 'title') { startGame(); return; }
    mouseDown = true;
    mouseStartX = e.clientX;
    mouseStartY = e.clientY;
    mouseShipStartX = shipX;
    mouseShipStartY = shipY;
});

canvas.addEventListener('mousemove', e => {
    if (!mouseDown) return;
    const dx = (e.clientX - mouseStartX) / (canvas.width * 0.3);
    const dy = (e.clientY - mouseStartY) / (canvas.height * 0.3);
    shipX = Math.max(-1, Math.min(1, mouseShipStartX + dx));
    shipY = Math.max(-0.5, Math.min(1, mouseShipStartY + dy));
});

canvas.addEventListener('mouseup', () => { mouseDown = false; });
canvas.addEventListener('mouseleave', () => { mouseDown = false; });

// Title screen touch/click
document.getElementById('title-screen').addEventListener('click', startGame);
document.getElementById('title-screen').addEventListener('touchstart', e => {
    e.preventDefault();
    startGame();
}, { passive: false });

// ── Game loop ─────────────────────────────────────────────────────
function loop() {
    requestAnimationFrame(loop);
    update();
    render();
}
loop();
</script>
</body>
</html>
